# 登录、权限和路由系统逻辑说明

## 📋 目录结构概览

```
src/
├── boot/           # Quasar启动文件
│   ├── auth.js     # 权限指令注册（v-permission, v-role）
│   └── router.js   # 路由启动初始化
├── router/         # 路由配置
│   ├── index.js    # 路由实例和守卫
│   ├── routes.js   # 静态路由配置
│   └── dynamicRoutes.js  # 动态路由生成逻辑
└── stores/         # 状态管理
    └── auth.js     # 认证状态管理
```

---

## 🔄 完整流程图

### 1. 应用启动流程

```
应用启动
    ↓
boot/router.js 执行
    ↓
检查是否有token？
    ├─ 有 → 调用 authStore.initializeAuth()
    │       ↓
    │       获取用户信息（getUserInfo）
    │       ↓
    │       获取用户菜单（getUserMenus）
    │       ↓
    │       初始化动态路由（initDynamicRoutes）
    │       ↓
    │       标记 routesLoaded = true
    │
    └─ 无 → 跳过初始化，等待用户登录
```

### 2. 用户登录流程

```
用户访问登录页（/login）
    ↓
输入用户名、密码
    ↓
完成滑块验证码
    ↓
点击登录按钮
    ↓
调用 authStore.login(loginData)
    ├─ 调用后端登录API
    ├─ 保存 token 和 refreshToken
    ├─ 保存 userInfo 到 localStorage
    ├─ 调用 getUserInfo() 获取用户详细信息
    └─ 调用 getUserMenus() 获取用户菜单
    ↓
LoginPage.vue 手动初始化动态路由
    ↓
跳转到首页或重定向URL
```

### 3. 路由守卫流程

```
用户访问任意路由
    ↓
router/index.js beforeEach 守卫拦截
    ↓
是否在白名单（/login, /register, /404）？
    ├─ 是 → 直接放行
    └─ 否 → 继续检查
        ↓
        是否有 token？
        ├─ 无 → 重定向到 /login
        └─ 有 → 继续检查
            ↓
            是否有 userInfo？
            ├─ 无 → 获取用户信息 + 菜单 + 初始化路由
            └─ 有 → 继续检查
                ↓
                动态路由是否已加载？
                ├─ 无 → 初始化动态路由
                └─ 有 → 放行
```

---

## 📁 核心文件详解

### 1. `stores/auth.js` - 认证状态管理

**核心职责：**
- 管理用户认证状态（token、userInfo、permissions、roles、menus）
- 提供登录、登出、刷新token等方法
- 管理权限和菜单数据

**关键状态：**
```javascript
state: {
  token: null,              // 访问令牌
  refreshToken: null,       // 刷新令牌
  userInfo: null,           // 用户基本信息（持久化到localStorage）
  permissions: [],          // 用户权限列表（不持久化，每次实时获取）
  roles: [],               // 用户角色列表（不持久化）
  menus: [],               // 用户菜单树（不持久化）
  routesLoaded: false,     // 动态路由是否已加载
  isInitializing: false,   // 是否正在初始化
  redirectUrl: null        // 登录后重定向URL
}
```

**关键方法：**

#### `login(loginData)` - 登录
1. 调用后端登录API
2. 保存 token 和 refreshToken 到 state 和 localStorage
3. 如果响应包含 userInfo，直接使用；否则调用 getUserInfo()
4. 调用 getUserMenus() 获取菜单数据

#### `getUserInfo()` - 获取用户信息
1. 调用后端API获取用户详细信息
2. 从响应中提取 userInfo、permissions、roles
3. 只将 userInfo 保存到 localStorage（权限数据不持久化）

#### `getUserMenus()` - 获取用户菜单
1. 调用后端API获取菜单树
2. 从菜单树中提取权限标识
3. 合并到 permissions 数组中
4. 不保存到 localStorage（确保实时更新）

#### `initializeAuth()` - 初始化认证信息
1. 检查是否有 token
2. 调用 getUserInfo()
3. 调用 getUserMenus()
4. 用于应用启动时恢复用户状态

#### `clearAuth()` - 清除认证信息
1. 清空所有状态
2. 清除 localStorage 中的认证数据
3. 清除动态路由组件映射缓存

---

### 2. `router/index.js` - 路由守卫

**核心职责：**
- 创建路由实例
- 实现路由守卫逻辑
- 控制页面访问权限

**路由守卫逻辑（beforeEach）：**

```javascript
// 1. 白名单检查
if (whiteList.includes(to.path)) {
  next()  // 直接放行
  return
}

// 2. 登录检查
if (!authStore.token) {
  next('/login')  // 未登录，跳转登录页
  return
}

// 3. 用户信息检查
if (!authStore.userInfo) {
  // 获取用户信息和菜单
  await authStore.getUserInfo()
  await authStore.getUserMenus()
  // 初始化动态路由
  await initDynamicRoutes(Router, false)
  authStore.routesLoaded = true
  next()
  return
}

// 4. 动态路由检查
if (!authStore.routesLoaded) {
  // 确保菜单数据存在
  if (!authStore.menus || authStore.menus.length === 0) {
    await authStore.getUserMenus()
  }
  // 初始化动态路由
  await initDynamicRoutes(Router, false)
  authStore.routesLoaded = true
  next()
  return
}

// 5. 所有检查通过，放行
next()
```

**特殊处理：**
- 如果目标路由是根路径 `/`，重定向到 `/dashboard`
- 如果路由初始化失败，允许访问基础页面（dashboard、profile）
- 支持路由不存在时的重新初始化机制

---

### 3. `router/routes.js` - 静态路由配置

**核心职责：**
- 定义应用的基础静态路由
- 包含登录页、主布局、404页面等

**路由结构：**
```javascript
[
  { path: '/login', component: LoginPage },           // 登录页
  { 
    path: '/', 
    name: 'MainLayout',
    component: MainLayout,
    redirect: '/dashboard',
    children: [
      { path: 'dashboard', component: DashboardPage }, // 仪表盘
      { path: 'profile', component: ProfilePage }      // 个人中心
    ]
  },
  { path: '/404', component: ErrorNotFound },         // 404页面
  { path: '/:catchAll(.*)*', redirect: '/404' }       // 捕获所有未匹配路由
]
```

---

### 4. `router/dynamicRoutes.js` - 动态路由生成

**核心职责：**
- 根据后端返回的菜单数据生成动态路由
- 管理组件映射关系
- 提供路由注册和清理功能

**关键概念：**

#### 组件映射表（componentMap）
- 使用 `import.meta.glob` 预加载所有页面组件
- 从后端API获取组件路径映射配置
- 支持多种路径格式的规范化

#### 路径规范化（normalizeComponentPath）
支持以下路径格式：
- `system/user` → 原始路径
- `pages/system/user` → 添加pages前缀
- `pages/system/userPage` → 页面组件格式
- `system/user/UserPage` → 标准页面路径

#### 菜单转路由（transformMenuToRoute）
```javascript
菜单数据结构：
{
  menuId: 1,
  menuName: "用户管理",
  menuType: 1,        // 0=目录, 1=菜单, 2=按钮
  path: "/system/user",
  component: "system/user",
  icon: "people",
  permission: "system:user:list",
  isVisible: 1,
  isCache: 1,
  children: [...]
}

转换为路由：
{
  path: "system/user",
  name: "SystemUser",
  component: () => import('../pages/system/user/UserPage.vue'),
  meta: {
    title: "用户管理",
    icon: "people",
    permission: "system:user:list",
    keepAlive: true,
    hidden: false
  }
}
```

**关键方法：**

#### `loadComponentMappingFromAPI()` - 加载组件映射
1. 调用后端API获取组件映射配置
2. 清空现有映射
3. 注册新的组件映射到 componentMap
4. 使用 `import.meta.glob` 预加载的模块进行动态导入

#### `getUserRoutes()` - 获取用户路由
1. 从API或localStorage获取菜单数据
2. 确保组件映射已加载
3. 遍历菜单树，转换为路由配置
4. 返回路由数组

#### `addDynamicRoutes(router, routes)` - 添加动态路由
1. 遍历路由数组
2. 使用 `router.addRoute('MainLayout', route)` 添加到主布局下
3. 记录成功和失败的数量

#### `initDynamicRoutes(router, usePersistedMenus)` - 初始化动态路由
1. 获取用户路由配置
2. 添加动态路由到路由实例
3. 返回初始化结果

#### `resetDynamicRoutes(router)` - 重置动态路由
1. 获取所有路由
2. 移除非基础路由（保留 dashboard、profile 等）
3. 用于登出时清理路由

---

### 5. `boot/router.js` - 路由启动初始化

**核心职责：**
- 应用启动时检查用户登录状态
- 如果已登录，初始化用户信息和动态路由

**执行流程：**
```javascript
if (authStore.token) {
  // 1. 设置初始化状态
  authStore.isInitializing = true
  
  // 2. 延迟确保模块加载完成
  await new Promise(resolve => setTimeout(resolve, 100))
  
  // 3. 获取最新用户信息和菜单
  await authStore.initializeAuth()
  
  // 4. 初始化动态路由
  const routeSuccess = await initDynamicRoutes(router, true)
  
  // 5. 标记路由已加载
  if (routeSuccess) {
    authStore.routesLoaded = true
  }
  
  authStore.isInitializing = false
}
```

**错误处理：**
- 如果获取权限数据失败（401错误），清除认证信息
- 防止token过期导致的无限循环

---

### 6. `boot/auth.js` - 权限指令

**核心职责：**
- 注册全局权限指令
- 提供模板中的权限控制

**指令说明：**

#### `v-permission` - 权限指令
```vue
<!-- 只有拥有 system:user:delete 权限的用户才能看到此按钮 -->
<q-btn v-permission="'system:user:delete'" label="删除" />
```

实现逻辑：
```javascript
app.directive('permission', {
  mounted(el, binding) {
    const authStore = useAuthStore()
    if (!authStore.hasPermission(binding.value)) {
      el.parentNode?.removeChild(el)  // 移除DOM元素
    }
  }
})
```

#### `v-role` - 角色指令
```vue
<!-- 只有管理员角色才能看到此按钮 -->
<q-btn v-role="'admin'" label="管理" />
```

实现逻辑：
```javascript
app.directive('role', {
  mounted(el, binding) {
    const authStore = useAuthStore()
    if (!authStore.hasRole(binding.value)) {
      el.parentNode?.removeChild(el)  // 移除DOM元素
    }
  }
})
```

---

## 🔐 权限控制机制

### 1. 数据来源

**权限数据有两个来源：**

1. **用户信息接口（getUserInfo）**
   - 返回用户的基本权限列表
   - 格式：`['system:user:list', 'system:user:add', ...]`

2. **菜单接口（getUserMenus）**
   - 返回菜单树结构
   - 从菜单的 `permission` 字段提取权限
   - 与用户信息接口的权限合并

**合并逻辑：**
```javascript
// 从菜单树提取权限
const menuPermissions = extractPermissionsFromMenus(menus)

// 合并去重
const allPermissions = [
  ...new Set([...existingPermissions, ...menuPermissions])
]

this.permissions = allPermissions
```

### 2. 权限检查方式

#### 方式1: 使用指令（推荐）
```vue
<template>
  <q-btn v-permission="'system:user:delete'" label="删除" />
</template>
```

#### 方式2: 使用方法
```vue
<template>
  <q-btn v-if="authStore.hasPermission('system:user:delete')" label="删除" />
</template>

<script setup>
import { useAuthStore } from 'src/stores/auth'
const authStore = useAuthStore()
</script>
```

#### 方式3: 在路由meta中定义
```javascript
{
  path: 'user',
  component: UserPage,
  meta: {
    permission: 'system:user:list'  // 路由级别的权限控制
  }
}
```

### 3. 数据持久化策略

**持久化到 localStorage：**
- ✅ token
- ✅ refreshToken
- ✅ userInfo（用户基本信息）
- ✅ redirectUrl（重定向URL）

**不持久化（每次实时获取）：**
- ❌ permissions（权限列表）
- ❌ roles（角色列表）
- ❌ menus（菜单树）

**原因：**
- 确保权限数据始终是最新的
- 避免权限变更后用户仍使用旧权限
- 防止localStorage数据过大

---

## 🚀 典型场景流程

### 场景1: 首次登录

```
1. 用户访问 /login
2. 输入用户名密码，完成验证码
3. 点击登录
   ├─ authStore.login() 调用登录API
   ├─ 保存 token 到 localStorage
   ├─ 获取 userInfo 并保存
   ├─ 获取 menus 和 permissions（不保存）
4. LoginPage 手动初始化动态路由
   ├─ loadComponentMappingFromAPI() 加载组件映射
   ├─ getUserRoutes() 生成路由配置
   ├─ addDynamicRoutes() 注册路由
5. 跳转到首页 /dashboard
```

### 场景2: 刷新页面

```
1. 页面刷新，应用重新启动
2. boot/router.js 执行
   ├─ 检测到 localStorage 中有 token
   ├─ 调用 authStore.initializeAuth()
   │   ├─ getUserInfo() 获取最新用户信息
   │   └─ getUserMenus() 获取最新菜单
   ├─ initDynamicRoutes() 初始化路由
   └─ 标记 routesLoaded = true
3. 路由守卫检查
   ├─ 有 token ✓
   ├─ 有 userInfo ✓
   ├─ routesLoaded = true ✓
   └─ 放行
4. 正常访问页面
```

### 场景3: 直接访问受保护页面

```
1. 用户在浏览器输入 /system/user
2. 路由守卫拦截
   ├─ 不在白名单
   ├─ 检查 token
   │   ├─ 无 token → 保存 redirectUrl = /system/user
   │   └─ 跳转到 /login
3. 用户登录成功
   ├─ 获取 redirectUrl
   ├─ 初始化动态路由
   └─ 跳转到 /system/user
```

### 场景4: 登出

```
1. 用户点击登出按钮
2. 调用 authStore.logout()
   ├─ 调用后端登出API
   ├─ 执行 clearAuth()
   │   ├─ 清空所有 state
   │   ├─ 清除 localStorage
   │   └─ 调用 clearAllComponents() 清除组件映射
   └─ resetDynamicRoutes() 清除动态路由
3. 跳转到 /login
```

---

## ⚙️ 配置说明

### 1. 白名单路由

在 `router/index.js` 中配置：
```javascript
const whiteList = ['/login', '/register', '/404']
```

这些路由不需要登录即可访问。

### 2. 基础路由

在 `router/routes.js` 中定义的静态路由：
- `/login` - 登录页
- `/` - 主布局
- `/dashboard` - 仪表盘
- `/profile` - 个人中心
- `/404` - 404页面

### 3. 动态路由

由后端菜单接口返回，前端动态生成：
- 根据用户权限动态添加
- 支持多级嵌套
- 支持权限控制

---

## 🐛 常见问题

### 1. 刷新页面后动态路由丢失

**原因：** 动态路由不持久化，刷新后需要重新加载

**解决：** boot/router.js 在应用启动时自动重新初始化路由

### 2. 权限更新后不生效

**原因：** 权限数据缓存在 store 中

**解决：** 
- 权限数据不持久化到 localStorage
- 每次启动都重新获取最新权限
- 或者手动调用 `authStore.getUserInfo()` 刷新

### 3. 组件加载失败

**原因：** 组件路径映射不正确

**解决：**
- 检查后端返回的组件路径是否正确
- 确保组件文件存在于 `src/pages/` 目录
- 查看控制台日志，确认路径匹配逻辑

### 4. 路由守卫死循环

**原因：** token过期但未清除，导致不断尝试获取用户信息

**解决：**
- 在 getUserInfo 失败时检查 401 错误
- 自动调用 clearAuth() 清除过期token
- 重定向到登录页

---

## 📝 最佳实践

### 1. 权限控制

- ✅ 优先使用 `v-permission` 指令
- ✅ 按钮级权限控制在模板中完成
- ✅ 路由级权限在 meta 中定义
- ❌ 避免在代码中硬编码权限字符串

### 2. 路由管理

- ✅ 静态路由放在 routes.js
- ✅ 动态路由由后端菜单生成
- ✅ 使用路由懒加载提升性能
- ❌ 不要手动修改动态路由

### 3. 状态管理

- ✅ 敏感数据（token）持久化
- ✅ 权限数据实时获取
- ✅ 使用 getter 封装权限检查逻辑
- ❌ 不要在组件中直接修改 store

### 4. 错误处理

- ✅ 捕获所有异步操作的错误
- ✅ 401错误自动清除认证信息
- ✅ 提供友好的错误提示
- ❌ 不要忽略错误

---

## 🔧 调试技巧

### 1. 查看路由状态

```javascript
// 在控制台执行
router.getRoutes()  // 查看所有已注册路由
```

### 2. 查看权限数据

```javascript
// 在控制台执行
import { useAuthStore } from 'src/stores/auth'
const authStore = useAuthStore()
console.log(authStore.permissions)  // 查看权限列表
console.log(authStore.menus)        // 查看菜单树
```

### 3. 查看组件映射

```javascript
// 在控制台执行
import { getComponentMapInfo } from 'src/router/dynamicRoutes'
console.log(getComponentMapInfo())  // 查看组件映射信息
```

### 4. 启用详细日志

代码中已包含详细的 console.log，查看浏览器控制台：
- 🚦 路由守卫日志
- 🔐 登录流程日志
- 📋 菜单加载日志
- 🛣️ 路由初始化日志

---

## 📚 相关API接口

### 1. 认证相关

- `POST /auth/login` - 登录
- `POST /auth/logout` - 登出
- `POST /auth/refresh` - 刷新token
- `GET /auth/userinfo` - 获取用户信息

### 2. 菜单相关

- `GET /menu/user-menus` - 获取用户菜单树
- `GET /menu/component-mapping` - 获取组件路径映射

---

## 🎯 总结

这套系统实现了：

1. **完整的认证流程**
   - 登录/登出
   - Token管理
   - 自动刷新

2. **灵活的权限控制**
   - 指令级控制
   - 路由级控制
   - 按钮级控制

3. **动态路由系统**
   - 根据权限动态生成
   - 支持多级嵌套
   - 自动组件映射

4. **良好的用户体验**
   - 刷新页面保持登录状态
   - 自动重定向到目标页面
   - 友好的错误提示

5. **安全性保障**
   - 权限实时验证
   - Token过期自动处理
   - 敏感数据加密传输
